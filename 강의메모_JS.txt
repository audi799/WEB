[ 변수 ]
- 변수(Variable)는 선언(Declaration) 및 값 초기화(Initialization) 이후 값이 변할 수 있는 것을 의미한다.
- 변수 선언 시 별도의 자료형(타입)을 명시하지 않고, 명명법으로 카멜케이스를 사용한다.
- 동일한 스코프(scope)에서 사용중인 이름이나 약속된 키워드를 변수의 이름으로 사용할 수 없다.
- 변수 선언 시 값을 부여(Assign)하지 않으면 초기 값으로 undefined 가 할당된다.
- 변수 선언
    let [변수 이름];
    #위 처럼 값 초기화 없이 변수를 선언할 경우 그 값은 undefined 로 초기화 된다.
- 변수 선언 및 값 초기화
    let [변수 이름] = [값];

[ 상수 ]
- 상수(Constant)는 선언 및 값 초기화 이후 값이 변하지 않는 것을 의미한다.
- 상수 선언 시 별도의 자료형(타입)을 명시하지 않고, 명명법으로 카멜케이스를 사용한다.
- 동일한 스코프(scope)에서 사용중인 이름이나 약속된 키워드를 변수의 이름으로 사용할 수 없다.
- 상수는 선언 시 값을 반드시 부여하여야 한다.
- 상수 선언 및 값 초기화
    const [상수 이름] = [값];

## 자료형 ##
[ 문자열 ]
- 문자열 자료형을 표현하기 위해서 홑따옴표(') 혹은 쌍따옴표(") 백틱(`)을 사용한다.
- 백틱을 사용한 문자열은 표현식(${})을 활용하여 문자열 사이에 외부 변수나 상수를 삽입하기 쉽고, 개행을 위한 문자열이며 이어 붙이기가 필요없이 편리하다.
- HTML과의 연동이 많은 자바스크립트 특성상 쌍따옴표를 많이 사용하는 HTML을 위하여 문자열 표현시 쌍따옴표를 많이 사용하지 않고, 홑따옴표를 많이 사용한다.

[ 숫자 ]
- 별도의 특수문자를 사용하지 않으며, 자바스크립트의 숫자는 정수와 실수를 별도로 구분하지 않는다.

[ 논리값 ]
- 별도의 특수문자를 사용하지 않으며 참 (true) 과 거짓 (false) 으로 이루어져 있다.

[ 널리쉬(Nullish) ]
- 널리쉬(Nullish) 는 null 과 undefined 를 포함한다.
- null 은 스택 영역의 값이 힙 영역을 가리키고 있으나, 힙 영역이 비어 있음을 의미한다.
- undefined 는 스택 영역이 비어있음을 의미한다.
- typeof null 은 object 임에 유의한다.
- typeof undefined 는 undefined 임에 유의한다.
- 어떠한 널리쉬 값에 대해 null 을 피연산자로 동등(==) 비교시 참(true)이 연산됨을 활용할 수 있다.
- null == undefined 는 참(true) 이다.

## 배열 ##
- 배열(Array)은 하나의 변수가 여러개의 값을 가질 수 있도록 하기위해 사용한다.
- 배열의 작성 형태는 JSON(JavaScript Object Notation) Array 의 형태와 같다.
- 배열은 대괄호([,]) 로 인자(들)을 감싸고, 각 인자는 쉼표(,)로 구분할 수 있다.
- 배열이 가지는 인자는 순번(인덱스)을 가지고, 해당 순번은 반드시 0 번 부터 시작하며, 배열에 대괄호([,]) 인자 접근 연산자를 사용하여 각 인자에 접근할 수 있다.
    let [변수 이름] = [[인자,....]];
    #가령, 'Apple', 'Banana', 'Orange' 라는 세 개의 문자열을 인자로 가지는 fruits 라는 배열은 아래와 같이 만들 수 있다.
    let fruits = ['Apple', 'Banana', 'Orange'];
    #배열이 가지는 인자는 순번(인덱스)을 가지는데, 첫번째 인자인 'Apple' 부터 0번이며, 순차적으로 1씩 증가한다.
    #아래와 같이 배열이 인자 접근 연산자와 순번을 통해 각 인자에 접근할 수 있다.
    console.log(fruits[0]); // 'Apple'
    console.log(fruits[2]); // 'Orange'

    #추가로, 인자 접근 시 음수나 범위를 벗어난 값을 전달할 경우 undefined 가 된다.
    console.log(fruits[-1]); // undefined
    console.log(fruits[3]); // undefined

[ 객체 속성 ]
- length: 배열이 가지고 있는 인자의 개수이다.

[ 객체 함수 ]
- at(x) : 호출 대상인 배열이 가지고 있는 순번이 x 인 인자를 반환한다. (인자가 음수면 역순으로 인자 반환함)
- concat(x) : 호출 대상인 배열과 인자인 배열 x 를 이어 붙인 새로운 배열을 반환한다.
- fill(...)
  + fill(x): 호출 대상인 배열이 가지고 있는 모든 인자를 x 로 대체한다.
  + fill(x, f): 호출 대상인 배열이 가지고 있는 모든 인자들 중 순번이 f 이상인 인자를 x 로 대체한다.
  + fill(x, f, t): 호출 대상인 배열이 가지고 있는 모든 인자들 중 순번이 f 이상이고 t 미만인 인자를 x 로 대체한다.
- includes(x): 호출 대상인 배열이 가지고 있는 인자 중 그 값이 x 와 일치하는 인자가 존재하는가의 여부를 반환한다.
- indexof(x): 호출 대상인 배열이 가지고 있는 인자 중 그 값이 x와 일치하는 첫번쨰 인자의 인덱스를 반환한다. 그러한 인자가 없다면 -1 을 반환한다.
- join(...)
  + join(): 호출 대상인 배열이 가지고 있는 인자를 쉼표(,)로 이어붙인 문자열을 반환한다.
  + join(x): 호출 대상인 배열이 가지고 있는 인자를 x 로 이어붙인 문자열을 반환한다.
- lastindexof(x): 호출 대상인 배열이 가지고 있는 인자 중 그 값이 x와 일치하는 마지막 인자의 인덱스를 반환한다. 그러한 인자가 없다면 -1 을 반환한다.
- pop(): 호출 대상인 배열이 가지고 있는 인자 중 마지막 인자를 배열에서 제거하고 이를 반환한다.
- push(x): 호출 대상인 배열의 끝에 새로운 인자 x 를 추가하고, 배열의 길이(length)를 반환한다.
- reverse(): 호출 대상인 배열이 가지고 있는 인자의 순서를 뒤집는다.
- shift(): 호출 대상인 배열이 가지고 있는 인자 중 첫번째 인자를 배열에서 제거하고 이를 반환한다.
- slice(...)
  + slice(): 호출 대상인 배열이 가지고 있는 인자를 그대로 가지는 배열을 복사하여 반환한다.
  + slice(f): 호출 대상인 배열이 가지고 있는 인자 중 인덱스가 f 이상인 인자를 가지는 배열을 복사하여 반환한다.
  + slice(f, t): 호출 대상인 배열이 가지고 있는 인자 중 인덱스가 f 이상이고 t 미만인 인자를 가지는 배열을 복사하여 반환한다.
- sort(...)
  + sort(): 호출 대상인 배열이 가지고 있는 인자 값을 문자열이라고 가정하고, 이때의 아스키(ASCII)코드를 기준으로 오름차순 정렬하여 반환한다.
  + sort(f): 호출 대상인 배열이 가지고 있는 인자가 되는, 두개의 매개 변수 a, b 를 받는 함수 f 에 대해, 정렬시 a가 선행해야하는 경우 음수를, b가 선행해야하는 경우 양수를, 동률일 경우 0을 반환하는 함수를 직접 작성하여 이에 대해 정렬 및 반환한다.
- splice(...)
  + splice(i, d): 호출 대상이 되는 배열이 가지고 있는 인자 중 그 순번이 i인 것 부터 d 개를 제거하여 반환한다.
  + splice(i, d, ...v): 호출 대상이 되는 배열이 가지고 있는 인자 중 그 순번이 i 인것부터 d 개를 제거하여 반환하고, 가변인자 v의 첫번쨰 인자의 순번이 i 가 될수 있도록 추가한다.

[ (주로 화살표 함수와 함께 사용하는) 객체 메서드 ]
- every(f(x?, i?, a?)): 호출 대상이 되는 배열이 가지고 있는 모든 인자가 전달된 함수 f의 전달인자 x 로 전달되었을 때 함수 f 가 참(true)을 반환하는가의 여부를 반환한다. 함수 호출 시 전달되는 인자는 순서대로 아래와 같고, 선택적으로 사용할 수 있다.
    + x: 순차적으로 반복할 호출 대상인 배열이 가지는 인자.
    + i: 순차적으로 반복할 호출 대상인 배열이 가지는 인자의 순번.
    + a: 호출 대상인 배열.
- filter(f(x?, i?, a?)): 호출 대상이 되는 배열이 가지고 있는 인자 중 함수 f 의 전달 인자로 참(true)을 반환하는 인자만을 인자로 가지는 새로운 배열을 반환한다. 이를 만족하는 인자가 없다면 빈 배열([])을 반환한다.
- find(f(x?, i?, a?)): 호출 대상이 되는 배열이 가지고 있는 인자 중 함수 f 의 전달 인자로 참(true)을 반환하는 첫번째 인자를 반환한다. 그러한 인자가 없다면 undefined 를 반환한다.
- findIndex(f(x?, i?, a?)): 호출 대상이 되는 배열이 가지고 있는 인자 중 함수 f 의 전달 인자로 참(true)을 반환하는 첫번째 인자의 순번를 반환한다. 그러한 인자가 없다면 -1 를 반환한다.
- findLast(f(x?, i?, a?)): 호출 대상이 되는 배열이 가지고 있는 인자 중 함수 f 의 전달 인자로 참(true)을 반환하는 마지막 인자를 반환한다. 그러한 인자가 없다면 undefined 를 반환한다.
- findLastIndex(f(x?, i?, a?)): 호출 대상이 되는 배열이 가지고 있는 인자 중 함수 f 의 전달 인자로 참(true)을 반환하는 마지막 인자의 순번를 반환한다. 그러한 인자가 없다면 -1 를 반환한다.
- forEach(f(x?, i?, a?)): 호출 대상이 되는 배열이 가지고 있는 인자 전체에 대해 함수 f의 전달 인자로 해당 함수를 단순 반복 실행한다.
- map(f(x?, i?, a?)): 호출 대상이 되는 배열이 가지고 있는 각 인자에 대해 함수 f 의 전달 인자로 반환되는 값으로 치환되는 새로운 배열을 반환한다.
- reduce(f(c?, x?, i?, a?), s?): 호출 대상이 되는 배열이 가지고 있는 인자를 반복 누산하여 누산된 값을 반환한다.
  + c: 반복하고 있는 누산기(Accumulator)
  + s: 반복할 누산기의 초기값.
- some(f(x?, i?, a?)): 호출 대상이 되는 배열이 가지고 있는 인자 중 하나라도 함수 f의 전달 인자로 참(true)을 반환하는가의 여부를 반환한다.

[ 함수 ]
- 함수(Function)는 호출(Call, Invoke)가능한 대상이다.
- 함수는 반복적으로 여러곳에서 사용될 가능성이 높은 로직을 분리하기 위해 사용한다.
- 함수의 명명법은 카멜 케이스이고 주로 아래의 형태를 가지는 편이다.
  + [동사]
  + [동사][목적어]
  + to[목적어]

[ 함수 호출 ]
- 함수는 종류를 구분하지 않고, 아래와 같이 호출할 수 있다.
    [함수 이름][[전달 인자,...]?]

    #가령, parseInt 라는 이름을 가지는 함수에 전달인자 '314'를 전달하여 호출하는 표현은 아래와 같다.
    parseInt('314');

    #마찬가지로, console 의 멤버인 log 함수에 전달인자 'Hello World' 를 전달하여 호출하는 표현은 아래와같다.
    console.log('Hello World');

## 일반 함수 ##
[기명 함수]
    function [함수 이름] ([매개 변수, ...]) {
        [구현부]
    }

    #가령, 전달받은 매개 변수 a와 b 의 합을 반환하기 위한 함수 sum은 아래와 같이 만들 수 있다.
    function sum(a, b) {
      return a + b;
    }
    #return 키워드는 해당 함수의 호출 결과를 반환하기 위해 사용한다.
    #return 키워드는 해당 위치에서 해당 함수의 실행을 즉시 종료한다.
            추가로, 반환값 없이 해당 함수의 실행을 고의로 종료하기 위해 return;만 작성하기도 한다.
    #반환 값이 없는 함수의 경우 return 키워드를 작성하지 않기도 하는데, 이 떄 함수의 호출 결과는 undefined 이다.

[익명 함수]
    function ([매개 변수,...]) {
        [구현부]
    }
    #이름이 없는 함수로, 단독 사용이 불가하며 주로 생성 후 변수나 상수에 할당하거나, 다른 함수의 호출 시 인자로 활용한다.

[ 화살표 함수 ]
    [변수|상수 선언] = ([매개 변수,...]?) => {
        [구현부]
    };
    #화살표 함수는 다양한 변이가 존재하는데 이는 다음과 같다.
        + 매개 변수가 하나만 존재하는 경우: 매개 변수가 하나만 존재하는 경우 매개 변수를 위한 괄호를 생략하여도 된다.
        + 구현부가 하나의 구문으로 이루어지는 경우: 구현부가 하나의 구문으로 이루어지는 경우 중괄호를 생략하여도 된다.
          이 때, return 키워드도 생략한다.

## 오브젝트 ##
- 오브젝트(Object)는 키(Key)와 값(Value)으로 이루어진 쌍(Pair)의 집합을 가지는 객체이다.
- 오브젝트의 작성 형태는 JSON(JavaScript Object Notation) Object 의 형태와 같다.
- 오브젝트는 중괄호({,}) 로 각 쌍들을 감싸고, 키와 값은 클론(:)으로 구분하여, 이러한 키와 값으로 이루어진 쌍들을 쉼표(,)로 구분하여 하나의 오브젝트에 여러개의 쌍을 작성할 수 있다.
- 오브젝트가 가지는 쌍들에는 순서가 없음으로 순번(인덱스)를 통한 접근이 불가능하다.
- 오브젝트의 쌍이 가지고 있는 값에는 키를 통해 접근할 수 있고, 하나의 오브젝트가 가지는 동일한 계층의 키는 고유해야 한다.
- 오브젝트가 가지는 키는 반드시 문자열이어야 하고, 값의 타입에는 제한이 없다.
- 오브젝트의 선언은 아래와 같은 형태로 한다.
    let [이름] = {
        [키 1] : [값 1],
        [키 2] : [값 2],
        [키 3] : [값 3],
        ...
    };

    #가령, 국가 코드별 한국어 이름을 가지는 오브젝트의 구조는 아래와 같이 작성할 수 있다.
    let countryMap = {
        KR: '대한민국',
        US: '미국',
        JP: '일본',
        FR: '프랑스',
        DE: '독일'
    };

    #키 이름을 통해 오브젝트가 가지는 값에 접근하기 위해서는 오브젝트에 대괄호([]) 혹은 멤버접근(.)연산자를 사용할수 있다.
    console.log(countryMap.KR); //대한민국
    console.log(countryMap['KR']); //대한민국
    #멤버 접근(.)을 통해 접근할 때에는 키 이름을 문자열로 취급하여서는 안 된다.
    #대괄호([])를 통해 접근할 때에는 키 이름을 문자열로 취급하여야 한다.

[ 쌍 추가 및 값 변경 ]
- 오브젝트에 이미 존재하는 쌍의 값을 변경하거나, 존재하지 않는 쌍을 추가하기 위해아래와 같이 작성할 수 있다.
    [오브젝트].[키] = [값];
    [오브젝트].[[키 문자열]] = [값];

    // GB: '영국' 쌍 추가
    countryMap['GB'] = '영국';
    // FR의 값을 '불란서'로 변경.
    countryMap['FR'] = '불란서';

[ 쌍 삭제 ]
- 존재하는 쌍을 삭제하기 위해 아래와 같이 작성할 수 있다.
    delete [오브젝트].[키];
    delete [오브젝트].[[키 문자열]]];

    //키가 JP인 쌍 삭제
    delete countryMap['JP'];

[ 정적 함수 ]
- keys(x): 전달받은 오브젝트 x 가 가지는 키들을 인자로 가지는 1차원 배열을 반환한다.
    let keys = Object.keys(countryMap);
    // ['KR', 'US', 'JP', 'FR', 'DE']

- values(x): 전달받은 오브젝트 x 가 가지는 값들을 인자로 가지는 1차원 배열을 반환한다.
    let values = Object.values(countryMap);
    // ['대한민국', '미국', '일본', '프랑스', '독일']

## 연산자 ##
[ 할당 연산자 ]
- 일반 할당(=): x = y 꼴에서 y를 x에 할당한다.
- 더하기 복합 대입 연산(+=): x += y 꼴에서 x 와 y 를 더한 값을 x에 재할당한다.
- 빼기 복합 대입 연산(-=): x -= y 꼴에서 x 와 y 를 뺀 값을 x에 재할당한다.
- 곱하기 복합 대입 연산(*=): x *= y 꼴에서 x 와 y 를 곱한 값을 x에 재할당한다.
- 나누기 복합 대입 연산(/=): x /= y 꼴에서 x 와 y 를 나눈 몫을 x에 재할당한다.
- 나머지 복합 대입 연산(%=): x %= y 꼴에서 x 와 y 를 나눈 나머지를 x에 재할당한다.
- 거듭 제곱 복합 대입 연산(**=): x **= y 꼴에서 x 의 y 제곱을 x에 재할당한다.
- 논리 AND 복합 대입 연산(&&=): x &&= y 꼴에서 x 와 y 가 모두 참인가의 여부를 x에 재할당한다.
- 논리 OR 복합 대입 연산(||=): x ||= y 꼴에서 x 와 y 중 하나가 참인가의 여부를 x에 재할당한다.
- 널리쉬 병합 복합 대입 연산(??=): x ??= y 꼴에서 x가 널리쉬인 경우 y 값을, 아니라면 x 값을 재할당한다.

[ 비교 연산자 ]
- 동등(==): x == y 꼴에서 x와 y의 값이 같은가의 여부이다. 단, 다른 타입의 피연산자간의 비교를 시도한다.
- 부등(!=): x != y 꼴에서 x와 y의 값이 다른가의 여부이다. 단, 다른 타입의 피연산자간의 비교를 시도한다.
- 일치(===): x === y 꼴에서 x와 y의 값과 타입이 같은가의 여부이다.
- 불일치(!==): x !== y 꼴에서 x와 y의 값 혹은 타입중 하나 혹은 모두가 다른가의 여부이다.
- 초과(>): x > y 꼴에서 x가 y보다 큰가의 여부이다.
- 미만(<): x < y 꼴에서 x가 y보다 작은가의 여부이다.
- 이상(>=): x >= y 꼴에서 x가 y보다 크거나 같은가의 여부이다.
- 이하(<=): x <= y 꼴에서 x가 y보다 작거나 같은가의 여부이다.

[ 산술 연산자 ]
- 더하기(+): x + y 꼴에서 x 와 y 의 합이다. 단, 피연산자 중 하나 이상이 문자열일 경우 문자열 합치기를 수행한다.
- 빼기(-): x - y 꼴에서 x 에서 y 를 뺀 값이다.
- 곱하기(*): x * y 꼴에서 x 와 y 의 곱이다.
- 나누기(/): x / y 꼴에서 x 를 y 로 나눈 몫이다. 단, y 가 0 일 경우 결과는 무한(Infinity 혹은 -Infinity)이다.
- 나머지(%): x % y 꼴에서 x 를 y 로 나눈 나머지이다. 단, y 가 0 일 경우 NaN(Not a Number) 이다.
- 거듭제곱(**): x ** y 꼴에서 x 의 y 제곱이다. (x 의 y 승)
- 단항 양수(+): +x 꼴에서 변수 x의 부호를 강조하거나, x 의 타입이 number 가 아닐 때 number 로 형변환을 시도하게 한다.
- 단항 음수(-): -x 꼴에서 변수 x의 부호를 반전하거나, x 의 타입이 number 가 아닐 때 number 로 형변환을 시도하게 한다.
- 증가(++)
  + 전위 증가 : ++x 꼴에서 구문 실행 전 x 에 1 을 더한다.
  + 후위 증가 : x++ 꼴에서 구문 실행 후 x 에 1 을 더한다.
- 감소(--)
  + 전위 감소: --x 꼴에서 구문 실행 전 x 에 1 을 뺀다.
  + 후위 감소: x-- 꼴에서 구문 실행 후 x 에 1 을 뺀다.

[ 논리 연산자 ]
- 논리 AND (&&): x && y 꼴에서 조건 x와 y가 모두 참(true)인가의 여부이다.
- 논리 OR (||): x || y 꼴에서 조건 x와 y 중 하나가 참(true)인가의 여부이다.
- 논리 NOT, 부정(!): !x 꼴에서 x의 눈리를 부정(반전)한다.

[ 삼항 연산자 ]
- 삼항연산자(? : ): c ? t : f 꼴에서 조건 c 가 참(true)이라면 t. 거짓(false)이라면 f가 된다.

[ 기타 연산자 ]
- 멤버 접근(.): x.y 꼴에서 x의 멤버인 y에 접근하기 위해 사용한다.
- 배열 인자 접근([]): x[y] 꼴에서 배열인 x의 인자 중 순번이 y인 인자에 접근하기 위해 사용한다.
- 오브젝트 속성 접근([]): x[y] 꼴에서 오브젝트인 x의 쌍 중 키가 y인 쌍에 접근하기 위해 사용한다.
- 객체화(new): new T 꼴에서 타입 T를 객체화하기 위해 사용한다.
- 함수 호출( () ): f() 꼴에서 함수 f를 호출하기 위해 사용한다.
- 우선 연산( () ): (x) 꼴에서 연산 x를 우선하기 위해 사용한다.
- delete: delete x.y 꼴에서 오브젝트 x의 속성인 y를 삭제하기 위해 사용한다.
- instanceof: x instanceof T 꼴에서 객체 x 가 타입 T 이거나 상속, 구현 대상인가의 여부이다.
- typeof: typeof x 꼴에서 x의 타입이 문자열이다.
- 옵셔널 체이닝 멤버 접근 연산자(?.): x?.y 꼴에서 x의 멤버인 y에 접근할 때, x가 널리쉬라면, 오류를 발생시키는 대신 전체 결과를 undefined 로 갈음한다.
- 널리쉬 병합 연산자( ?? ): x ?? y 꼴에서 x 가 널리쉬 일때, y 값을 대신 사용하고, 그렇지 않으면 x를 그대로 사용한다.

## 연산자의 우선순위 ##
- 연산자 사이에는 연산되는 우선순위가 있으며 아래는 숫자가 작을수록 우선순위가 높다는 의미이다.
   (1번이 가장 높은 우선순위)
   1.우선 연산( () )
   2.멤버 접근, 옵셔널 체이닝 멤버 접근, 배열 인자 접근, 오브젝트 속성 접근(.,.,[],[])
   3.객체화, 함수호출( new, () )
   4.후위 증가, 후위 감소(++. --)
   5.전위 증가, 전위 감소, 논리 NOT, 단항 양수, 단항 음수, typeof, delete(++, --, !, +, -)
   6.거듭 제곱(**)
   7.곱하기, 나누기, 나머지(*, /, %)
   8.더하기, 빼기(+, -)
   9.초과,미만,이상,이하,instanceof (>, <, >=, <=)
  10.동등, 부등, 일치, 불일치(==, !=, ===, !==)
  11.논리 AND(&&)
  12.논리 OR(||)
  13.널리쉬 병합 연산자(??)
  14.삼항 연산( ? : )
  15.일반 할당, 복합 대입 연산( =, +=, -=, *=, /=, %=, **=, &&=, ||=, ??= 등)

## 반복문 ##
[ for ]
- for 반복문은 반복의 기준이 되는 변수(주로 인덱스)를 활용하여 특정 구현부를 반복하고자할 때 사용한다.
    for ([변수 선언 및 초기화]; [반복 조건]; [변수 가감 및 복합 대입]) {
        [구현부]
    }
    1.for 반복문을 위한 변수를 선언 및 초기화한다.
    2.반복 조건이 참(true) 인지 확인한다.
      + 반복 조건이 참(true) 이라면, 구현부를 1회 실행하고 [3.]으로 이동한다.
      + 반복 조건이 거짓(false) 이라면, 반복문 실행을 종료한다.
    3.변수 가감 및 복합 대입 을 실시하고 [2.]로 돌아간다.

[ for ... in ]
- for ... in 반복문은 문자열로 키가 지정된 열거 가능한 대상의 키를 반복하기 위해 사용한다.
- 단, 반복 대상이 배열일 경우 인덱스를 반복하지만 이를 목적으로 사용하지는 않는다.
    for([변수 혹은 상수 선언] in [반복대상]) {
        [구현부]
    }

[ for ... of ]
- for ... of 반복문은 반복할 수 있는 대상이 가지는 인자의 값에 대해 반복하기 위해 사용한다.
- 인덱스에 대한 변수가 필요 없을 경우 인덱스 범위 오류 및 가독성 향상 등을 위해 가능한 일반 for 반복문 보다 for ... of 반복문을 사용하는 것이 좋다.
    for([변수 혹은 상수 선언] of [반복 대상]) {
        [구현부]
    }

[ while ]
- while 반복문은 주어진 조건이 참(true)일 때, 횟수와 관계 없이 구현부를 실행하기 위해 사용한다.
    while ([조건]) {
        [구현부}
    }
    #만약 조건이 항상 참이거나, 거짓으로 변하는 경우의 수가 없다면, 혹은 break 및 return 등의 중단 키워드가 없는 경우 무한히 반복됨으로 유의해야한다.

[ do ... while ]
- do ... while 반복문은 while 반복문과 유사하나 조건과 관계 없이 최초 한 번은 반드시 구현부를 실행한다는 차이점이 있다.
    do {
        [구현부]
    }
    while ([조건]);

## 조건문 ##
[ if ]
- 주어진 조건이 참일때만 구현부를 실행하기 위해 사용한다.
    if ([조건]) {
        [구현부]
    }

[ else ]
- else 문은 단독으로 사용할 수 없고, if 문과 함께 사용햐여야 한다.
- else 문은 앞서 제시된 모든 조건이 거짓일 때 최종적으로 실행할 구현부를 위해 사용한다.
- else 문은 if 문 하나에 여러개 존재할 수 없다.
- else 문은 if 문의 마지막 구문이어야 한다.
    if ([조건]) {
        [참 구현부]
    } else {
        [거짓 구현부]
    }
    #위 예시에서 조건이 참일때는 참 구현부를, 거짓일때는 거짓 구현부를 실행한다.
    #조건이 논리임으로, 참 구현부 혹은 거짓 구현부 중 하나가 반드시 실행된다는 보장이 있다.

[ else if ]
- else if 문은 단독으로 사용할 수 없고, if 문과 함께 사용하여야 한다.
- else if 문은 앞서 제시된 모든 조건이 거짓일 때 부수적인 조건을 추가하여 해당 조건이 참일 때 구현부를 실행하기 위해 사용한다.
- else if 문은 if 문 하나에 여러개 존재할 수 있다.
- else if 문의 조건이 비록 참이라 하더라도 선행하는 if 혹은 else if 의 조건이 참이라면 해당 후행하는 else if 는 실행되지 않는다. (하나의 if 문에서 실행될 수 있는 구현부는 하나 이하임으로)
    if ([선행 조건 1]) {
        [선행 조건 1 구현부]
    } else if ([선행 조건 2]) {
        [선행 조건 2 구현부]
    } else if ([선행 조건 3]) {
        [선행 조건 3 구현부]
    } else {
        [거짓 구현부]
    }
    #위 예시에서 선행 조건 1 이 참일 경우 선행 조건 1 구현부 를 실행하고나머지 else if 와 else 는 고려하지 않는다.
    #위 예시에서 선행 조건 1 이 거짓이고 선행 조건 2 가 참인 경우 선행 조건 2 구현부 를 실행하고 후행하는 else if 와 else 는 고려하지 않는다.
    #위 예시에서 선행 조건 1 및 선행 조건 2 가 거짓이고 선행 조건 1이 참인 경우 선행 조건 3 구현부 를 실행하고 후행하는 else 는 고려하지 않는다.
    #위 예시에서 선행 조건 1, 선행 조건 2, 선행 조건 3 이 모두 거짓이라면 else 를 실행한다.
    #즉, else if 의 개수 및 else 의 존재 여부와 무관하게 하나의 if 문에 존재하는 구현부는 실행되지 않거나, 단 한개만 실행 할 수 있다.

## 분기문 ##
[ switch ]
- switch 분기문은 분기 대상 변수가 가지는 값에 따라 case 를 활용하여 실행할 구문을 분리하기 위해 사용한다.
    switch ([분기 대상 변수]) {
      case [값 1]:
            [값 1 구현부]
            [break;]?
      case [값 2]:
            [값 2 구현부]
            [break;]?
      [default:]?
            [default 구현부]?
    }
    #분기 대상 변수가 가지는 값이 각 case 에 명시된 값 과 일치하는 가장 빠른 case 의 구현부가 실행된다.
    #일치하는 case 가 없다면 default 구현부가 실행된다.
    #break 키워드는 해당 위치에서 switch 분기문을 종료하겠다는 의미이다.
    #default 는 여러개 존재할 수 없으며 작성시 반드시 switch 의 마지막에 위치해야 된다.

## 요소 ##
[ window ]
- window 객체는 자바스크립트의 최상위 객체이면서 브라우저와 관련된 멤버를 모두 가지고 있다.
- 전역적으로 사용할 수 있는 대상이 모두 window 객체의 멤버로 할당되어 있다.

[ document ]
- window 의 멤버로, HTML 문서( <html> 부터 </html> 까지 )에 대한 멤버를 가지는 객체이다.
- 속성
  + head: <head> 태그에 대한 멤버를 가지는 객체이다.
  + body: <body> 태그에 대한 멤버를 가지는 객체이다.
- 함수
  + createElement(x): 태그의 종류가 x 인 가상의 요소를 만들어 반환한다.
  + getElementById(x): HTML id 속성 값으로 문자열인 x 를 가지는 요소를 선택하여 반환한다.
                       그러한 요소가 없다면 null 을 반환한다.

[ HTMLElement ]
- HTMLElement 는 HTML의 모든 태그를 자바스크립트 객체로 표현하기 위한 타입이다.
- 객체 속성
  + addEventListener(e, f): 호출 대상인 요소에 이벤트 e 가 발생했을 때 함수 f를 실행하기위한 이벤트 리스너를 추가한다.
  + removeEventListener(e, f): 호출 대상인 요소가 가지고 있는 이벤트 리스너 중 이벤트의 종류가 e 이고 함수가 f인 이벤트 리스너를 제거한다. 여기서 제거할 함수 f 는 이벤트 리스너 추가( addEventListener ) 시 사용한 함수와 동일한 함수를 가리켜야 한다.
    + 이벤트의 종류(e)
      # click: 클릭했을 때의 이벤트
      # mousedown: 마우스 버튼을 눌렀을 때의 이벤트
      # mouseup: 마우스 버튼을 뗐을 때의 이벤트
      # mousemove: 마우스 커서가 움직일 때의 이벤트
      # mouseenter: 마우스 커서가 해당 요소의 밖에 있다가 내부에 진입 했을 때의 이벤트
      # mouseleave: 마우스 커서가 해당 요소의 엔에 있다가 외부로 나갔을 때의 이벤트
      # wheel: 마우스 휠이 돌아갔을 때의 이벤트
      # focusin: 포커스를 가질 수 있는 요소가 포커스를 가지게 되었을 때
      # focusout: 포커스를 가질 수 있는 요소가 포커스를 잃게 되었을 때
      # keydown: 키보드의 키가 눌렸을 때의 이벤트
      # keyup: 키보드의 키가 떼졌을 때의 이벤트
  + classList: 해당 요소의 HTML class 속성과 관련된 멤버를 가지고 있는 속성이다.
    + add(x): 해당 요소의 class 속성에 x를 추가한다. 이미 있다면 중복되게 추가하지 않음.
    + contains(x): 해당 요소가 class 속성에 x 를 포함하는가의 여부를 반환한다.
    + remove(x): 해당 요소의 class 속성에서 x 를 제거한다.
    + toggle(x): 해당 요소의 class 속성이 x를 가지고 있다면 제거하고, 없다면 추가한다.
  + dataset: 해당 요소의 사용자 지정 데이타를 가져오거나, 지정하기 위한 속성이다. 오브젝트 속성 접근 연산자([])를 활용하여 해당 요소가 가지고 있는 data-* 속성의 이름으로 값에 접근할 수 있다.
             단, 접근 시 이름을 카멜케이스화 하여야 함에 유의한다.
             (가령 data-member-name 속성에 접근 시 dataset['memberName'] 으로 접근)
  + innerHTML: 해당 요소의 내부 HTML 코드인 문자열이다. 자동으로 닫는 태그의 경우 빈 문자열('')이다.
  + innerText: 해당 요소의 내부 텍스트(내용)이다. 자동으로 닫는 태그의 경우 빈 문자열('')이다.
  + style: 해당 요소의 CSS 와 관련된 멤버를 가지고 있는 속성이다. 해당 속성 사용 시, 해당 요소의 style 속성이 부여된다. 해당 속성의 멤버의 명명은 실제 CSS 속성을 카멜케이스화 한 것임에 유의한다.
           (가령, background-color 는 backgroundColor 로 접근)
- 객체 함수
  + append(...x): 호출 대상인 요소의 마지막 자식이 될 수 있도록 한 개 이상의 요소 x 를 추가한다.
  + prepend(...x): 호출 대상인 요소의 첫번째 자식이 될 수 있도록 한 개 이상의 요소 x 를 추가한다.
  + querySelector(x): 호출 대상이 되는 요소의 자식 혹은 자손이면서 CSS 선택자인 문자열 x를 가장 빨리 만족하는 요소 한 개를 반환한다. 그러한 요소가 없다면 null 을 반환한다.
  + querySelectorAll(x): 호출 대상이 되는 요소의 자식 혹은 자손이면서 CSS 선택자인 문자열 x를 만족하는 요소 전체를 인자로 가지는 유사 배열 객체 NodeList 를 반환한다. 그러한 요소가 없다면 길이가 0인 유사 배열 객체 NodeList 를 반환한다.
  + getAttribute(x): 호출 대상이 되는 요소가 가지고 있는 HTML 속성 중 이름이 x 인 것의 값을 문자열로 반환한다. 그러한 속성이 없다면 null 을 반환한다.
  + setAttribute(n, v): 호출 대상이 되는 요소에 이름은 n 이고 값은 v 인 속성에 추가/지정한다.
                        속성 값이 없다하더라도 v 는 누락하여서는 안 되며, 빈 문장열('')로 처리하여야 한다.
  + hasAttribute(x): 호출 대상이 되는 요소가 이름이 x 인 속성을 가지고 있는가의 여부를 반환한다.
  + removeAttribute(x): 호출 대상이 가지고 있는 속성 중 이름이 x 인 속성을 제거한다.

[ HTMLFormElement ]
- HTMLElement 타입을 상속받는 form 태그를 자바스크립트 객체로 표현하기 위한 타입이다.
- 해당 타입의 객체에 오브젝트 속성 접근 연산자([])를 활용하여 이가 가지는 입력 태그(button, input, select, textarea)의 name 속성 값을 문자열로 주면 해당 요소가 연산된다.

## XHR ##
- XHR(XML HTTP Request) 기술은 자바스크립트의 XMLHttpRequest 객체를 통해 구현할 수 있다. 흔히 AJAX (Asynchronous Javascript And XML)라고 부르기도 한다.
- 페이지 새로고침 없이, 비동기적으로 서버에 요청을 보내고 응답을 받아오기 위해 사용한다.
- 외부 리소스를 불러옴에 있어 페이지를 다시 불러올 필요가 없기 때문에 사용자 경험(Ux, User Experience)에 긍정적인 영향을 줌으로 많이 사용하는 편이다.
- 일반적으로 아래 구조와 같이 구현할 수 있다.
    const xhr = new XMLHttpRequest();
    xhr.onreadystatechange = function () {
        if (xhr.readyState !== XMLHttpRequest.DONE) {
            return;
        }
        if (xhr.status < 200 || xhr.status >= 400) {
            [요청 실패 구현부]
            return;
        }
        [요청 성공 구혀부]
    }
    xhr.open([요청 방식], [요청 주소]);
    xhr.send([요청 데이터]?);

- 정적 속성
  + UNSENT: XMLHttpRequest 타입 객체의 readyState 속성이 가질 수 있는 값으로 0 과 같고, XMLHttpRequest 객체가 객체화된 후 아무런 동작을 하지 않은 초기 상태이다.
  + OPENED: XMLHttpRequest 타입 객체의 readyState 속성이 가질 수 있는 값으로 1과 같고, open 함수 호출 후의 상태이다.
  + HEADERS_RECEIVED: XMLHttpRequest 타입 객체의 readyState 속성이 가질 수 있는 값으로 2와 같고, 요청 방식과 요청 주소의 유효성 검증 및 요청에 대한 상태 코드와 응답 헤더가 반환된 상태. 단, 응답의 본문은 반환되지 않음.
  + LOADING: XMLHttpRequest 타입 객체의 readyState 속성이 가질 수 있는 값으로 3과 같고, 응답의 본문을 다운로드(수신)하고 있는 상태.
  + DONE: XMLHttpRequest 타입 객체의 readyState 속성이 가질 수 있는 값으로 4와 같고, XMLHttpRequest 객체를 통한 통신이 성공 여부와 관계 없이 종료되었음을 의미한다. (통신 성공 여부는 해당 객체가 가지는 status 속성 값을 참고한다.)

- 객체 속성
  + readyState: 해당 객체의 대기 상태이다.
  + responseText: 서버가 응답으로 전송한 문자열 데이터 본문이다.
  + status: 해당 객체의 HTTP 상태 코드이다. 동일 객체의 readyState 속성이 HEADERS_RECEIVED 이상일 때 사용가능하다.
      # 200: OK. 정상 상태. (주로 200 이상 300 미만의 값을 정상 상태로 간주한다)
      # 400: Bad Request. 서버가 요구하고 있는 데이터를 클라이언트가 누락하였거나 그 데이터의 형태가 잘못되었음을 의미한다.
      # 401: Unauthorized. 비록 그 의미는 미승인이지만 실질적으로 미인증(unauthenticated)으로 사용되며, 주로 익명의 클라이언트가 해당 리소스에 접근할 권한이 없을 때 사용된다. (로그인요구)
      # 403: Forbidden. 클라이언트가 해당 리소스에 접근할 권한이 없을 때 사용된다. 401과의 차이는 403은 현재 서버가 클라이언트의 신원을 알고 있을 때 사용하는 편이라는 점이 있다.
      # 404: Not Found. 클라이언트가 요청한 리소스가 서버에 존재하지 않음을 의미한다.
      # 405: Method Not Allowed. 클라이언트가 요청한 리소스에 대한 주소(경로)는 존재하지만, 요청 방식이 허용되지 않음을 의미한다.
      # 500: Internal Server Error. 요청을 처리하는 도중 서버 내부에서 오류가 발생하였음을 의미한다.
      ####################################정리##########################################
      200~299: 성공 / 300~399: 가이드 / 400~499: 실패(클라이언트문제) / 500~599: 실패(서버문제)
      #################################################################################

- 객체 함수
  - open(m, u): 요청을 보낼 준비를 하기 위해 호출한다. 요청을 보낼 방식(Method)인 문자열을 m, 주소인 문자열을 u에 전달한다.
    + 요청 방식
      + GET: 일반적인 웹 브라우저의 주소창에 주소를 입력하고 요청을 보낼 때 사용하는 방식이다.
             데이타를 요청 주소에만 실어보낼 수 있고 일반적인 웹페이지에 대한 응답을 위한 요청이나, 데이타베이스 상에서 SELECT 쿼리가 발생하는경우 사용하는 요청 방식이다.
      + POST: 주로 데이타베이스 상에서 INSERT 쿼리가 발생하는 경우 사용하는 요청 방식이다.
              단, SELECT 만 발생하더라도 전송하는 데이타가 주소상에 노출되어서는 안 되는 경우, POST 방식을 사용하기도 한다.
      + DELETE: 주로 데이타베이스 상에서 DELETE 쿼리가 발생하는 경우 사용하는 요청 방식이다.
      + PATCH: 주로 데이타베이스 상에서 UPDATE 쿼리가 발생하는 경우 사용하는 요청 방식이다.
               해당 요청에 의해 레코드가 부분적으로 수정되는 경우 사용한다.
      + PUT: 주로 데이타베이스 상에서 UPDATE 쿼리가 발생하는 경우 사용하는 요청 방식이다.
             해당 요청에 의해 레코드 전체가 수정되는 경우 사용한다.
  - send(d): 요청을 전송한다. 이 때 d 는 요청을 함께 보낼 데이타이며(Request Body), 보낼 데이타가 없다면 생략 가능하다. 단, 요청 방식이 GET이라면 데이타를 함께 보낼 수 없다.

- 객체 이벤트
  - readystatechange: 해당 객체의 'readyState' 속성 값이 변할 때 마다 실행할 이벤트.

* 2025-03-11
$list.insertAdjacentHTML('beforebegin', '인서트할문자열');
@beforebegin
<div>
    @afterbegin
    ...기존 내용...
    @beforeend
</div>
@afterend


















